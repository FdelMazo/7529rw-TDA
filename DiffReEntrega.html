<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta charset="utf-8">
	<title>Pretty Diff</title>
	<style>
	body {
		text-align: center;
	}
	#wrapper {
		display: inline-block;
		margin-top: 1em;
		min-width: 800px;
		text-align: left;
	}
	h2 {
		background: #fafafa;
		background: -moz-linear-gradient(#fafafa, #eaeaea);
		background: -webkit-linear-gradient(#fafafa, #eaeaea);
		-ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr='#fafafa',endColorstr='#eaeaea')";
		border: 1px solid #d8d8d8;
		border-bottom: 0;
		color: #555;
		font: 14px sans-serif;
		overflow: hidden;
		padding: 10px 6px;
		text-shadow: 0 1px 0 white;
		margin: 0;
	}
	.file-diff {
		border: 1px solid #d8d8d8;
		margin-bottom: 1em;
		overflow: auto;
		padding: 0.5em 0;
	}
	.file-diff > div {
		width: 100%:
	}
	pre {
		margin: 0;
		font-family: "Bitstream Vera Sans Mono", Courier, monospace;
		font-size: 12px;
		line-height: 1.4em;
		text-indent: 0.5em;
	}
	.file {
		color: #aaa;
	}
	.delete {
		background-color: #fdd;
	}
	.insert {
		background-color: #dfd;
	}
	.info {
		color: #a0b;
	}
	</style>
</head>
<body>
<div id="wrapper">
<h2>TP1/Gale</h2><div class="file-diff"><div><pre class="file">diff --git a/TP1/Gale Shapley/matchingGS.py b/TP1/Gale Shapley/matchingGS.py</pre>
<pre class="file">index 9667e01..429e8b5 100644</pre>
<pre class="delete">--- a/TP1/Gale Shapley/matchingGS.py    </pre>
<pre class="insert">+++ b/TP1/Gale Shapley/matchingGS.py    </pre>
<pre class="info">@@ -36,7 +36,6 @@ def asignacion(diccJugadores, diccEquipos, vacantesDisponibles):</pre>
<pre class="context">                 if not jugadorActual.estaAsignado():</pre>
<pre class="context">                     equipo.agregarJugador(jugadorActual)</pre>
<pre class="context">                     vacantesDisponibles -=1</pre>
<pre class="delete">-</pre>
<pre class="context">                 else:</pre>
<pre class="context">                     equipoActual = jugadorActual.getLugarAsignado()</pre>
<pre class="context">                     if jugadorActual.compararPreferencias(equipo, equipoActual) &gt; 0:</pre>
<pre class="info">@@ -50,7 +49,7 @@ def guardarAsignacion(diccEquipos, nombreArchivo):</pre>
<pre class="context">         for numeroEquipo in diccEquipos.keys():</pre>
<pre class="context">             archivo.write("{}:".format(numeroEquipo))</pre>
<pre class="context">             for jugador in diccEquipos[numeroEquipo].getJugadores():</pre>
<pre class="delete">-                archivo.write(" {}".format(jugador.getNumero()))</pre>
<pre class="insert">+                archivo.write(" {}".format(jugador))</pre>
<pre class="context">             archivo.write('\n')</pre>
<pre class="context"> </pre>
<pre class="context"> </pre></div></div><h2>TP1/Informe/Informe.pdf</h2><div class="file-diff"><div><pre class="file">diff --git a/TP1/Informe/Informe.pdf b/TP1/Informe/Informe.pdf</pre>
<pre class="file">index 82e73ca..4ef7506 100644</pre>
<pre class="undefined">Binary files a/TP1/Informe/Informe.pdf and b/TP1/Informe/Informe.pdf differ</pre></div></div><h2>TP1/Informe/Informe.tex</h2><div class="file-diff"><div><pre class="file">diff --git a/TP1/Informe/Informe.tex b/TP1/Informe/Informe.tex</pre>
<pre class="undefined">old mode 100644</pre>
<pre class="undefined">new mode 100755</pre>
<pre class="file">index ae5e3fe..28f7e1a</pre>
<pre class="delete">--- a/TP1/Informe/Informe.tex</pre>
<pre class="insert">+++ b/TP1/Informe/Informe.tex</pre>
<pre class="info">@@ -13,6 +13,7 @@</pre>
<pre class="context"> \usepackage{graphicx}</pre>
<pre class="context"> \usepackage{float}</pre>
<pre class="context"> \usepackage{minted}</pre>
<pre class="insert">+\newcommand{\bigO}{\mathcal{O}}</pre>
<pre class="context"> </pre>
<pre class="context"> \pagestyle{fancy}</pre>
<pre class="context"> \fancyhf{}</pre>
<pre class="info">@@ -44,7 +45,7 @@</pre>
<pre class="context">     \hline</pre>
<pre class="context">     del Mazo, Federico &amp; 100029 &amp; delmazofederico@gmail.com\\</pre>
<pre class="context">     \hline</pre>
<pre class="delete">-    Djeordjian, Esteban Pedro &amp; 100701 &amp; edjeordjian@gmail.com\\    </pre>
<pre class="insert">+    Djeordjian, Esteban Pedro &amp; 100701 &amp; edjeordjian@gmail.com\\</pre>
<pre class="context">     \hline</pre>
<pre class="context">     Kristal, Juan Ignacio &amp; 99779 &amp; kristaljuanignacio@gmail.com\\</pre>
<pre class="context">     \hline</pre>
<pre class="info">@@ -69,7 +70,7 @@ El ordenamiento de selección es uno de los algoritmos de ordenamiento más faci</pre>
<pre class="context"> </pre>
<pre class="context"> De acuerdo a nuestra implementación\footnote{Las complejidades de los métodos nativos de las listas de Python 3 fueron sacadas de: \url{https://wiki.python.org/moin/TimeComplexity}} del ordenamiento de selección, la complejidad teórica es:</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Selección(n)} \in \mathcal O(2 + 1 + n * (1 + 1 + 1 + n * (1 + 1) + 1 + 2)) = \mathcal O(n^2 + 6n + n) \in \mathcal O(n^2)$</pre>
<pre class="insert">+$\mbox{T Selección(n)} \in \bigO(2 + 1 + n * (1 + 1 + 1 + n * (1 + 1) + 1 + 2)) = \bigO(n^2 + 6n + n) \in \bigO(n^2)$</pre>
<pre class="context"> </pre>
<pre class="context"> Esto viene de analizar linea por linea teniendo en cuenta:</pre>
<pre class="context"> \begin{itemize}</pre>
<pre class="info">@@ -82,7 +83,7 @@ Esto viene de analizar linea por linea teniendo en cuenta:</pre>
<pre class="context"> </pre>
<pre class="context"> Este ordenamiento itera siempre por el arreglo sin importar su disposicion inicial. Por lo tanto su caso promedio es iguales al tiempo analizado:</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Promedio Seleccción(n)} \in \mathcal O(n^2 + 6n + n) \in \mathcal O(n^2)$</pre>
<pre class="insert">+$\mbox{T Promedio Seleccción(n)} \in \bigO(n^2 + 6n + n) \in \bigO(n^2)$</pre>
<pre class="context"> </pre>
<pre class="context"> </pre>
<pre class="context"> \subsubsection{Inserción}</pre>
<pre class="info">@@ -91,11 +92,11 @@ Inicialmente, se tiene un solo elemento y se lo considera un conjunto ordenado.</pre>
<pre class="context"> </pre>
<pre class="context"> Este ordenamiento usa las mismas herramientas del ordenamiento de selección. Por lo tanto, con las consideraciones anteriores tomadas, queda:</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Inserción(n)} \in \mathcal O( 2 + 1 + n * (2 + 1 + 2 + 2 + 1 + n * (1 + 3))) = \mathcal O(4n^2 + 8n + 3) \in \mathcal O(n^2)$\\</pre>
<pre class="insert">+$\mbox{T Inserción(n)} \in \bigO( 2 + 1 + n * (2 + 1 + 2 + 2 + 1 + n * (1 + 3))) = \bigO(4n^2 + 8n + 3) \in \bigO(n^2)$\\</pre>
<pre class="context"> </pre>
<pre class="delete">-Como es claro que encontrar en un arreglo un intervalo ordenado (suficientemente grande) es mucho menos probable que no hacerlo (es decir, para un arreglo de n elementos, de las $n!$ posibles distribuciones de los elementos, solo una estara ordenada, y con un n no demasiado grande, se cumple que $n!-1 \approx n$). Luego, en el caso promedio se tiene que el algoritmo tambien tiene orden cuadratico.</pre>
<pre class="insert">+Como es claro que encontrar en un arreglo un intervalo ordenado (suficientemente grande) es mucho menos probable que no hacerlo (es decir, para un arreglo de $n$ elementos, de las $n!$ posibles distribuciones, sólo una estará  ordenada,  por lo que esa posibilidad se desprecia para el caso promedio). Luego, en el caso promedio se tiene que el algoritmo tambien tiene orden cuadratico.</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Promedio Inserción(n)} \in \mathcal O(4n^2 + 8n + 3) \in \mathcal O(n^2)$</pre>
<pre class="insert">+$\mbox{T Promedio Inserción(n)} \in \bigO(4n^2 + 8n + 3) \in \bigO(n^2)$</pre>
<pre class="context"> </pre>
<pre class="context"> \subsubsection{Mergesort}</pre>
<pre class="context"> </pre>
<pre class="info">@@ -104,37 +105,37 @@ El algoritmo de mergesort es un ordenamiento que utiliza la técnica de Divisió</pre>
<pre class="context"> En cuanto a código se introducen nuevos metodos:</pre>
<pre class="context"> </pre>
<pre class="context"> \begin{itemize}</pre>
<pre class="delete">-\item \texttt{Append} y \texttt{pop}: $\mathcal O(1)$</pre>
<pre class="delete">-\item \texttt{Extend}: $\mathcal O(k)$ siendo k la cantidad de elementos agregados </pre>
<pre class="insert">+\item \texttt{Append} y \texttt{pop}\footnote{El pop fue removido en la re-entrega. De todas formas, pop es $\bigO(1)$ solo cuando es respecto al último elemento}: $\bigO(1)$</pre>
<pre class="insert">+\item \texttt{Extend}: $\bigO(k)$ siendo k la cantidad de elementos agregados</pre>
<pre class="context"> \end{itemize}</pre>
<pre class="context"> </pre>
<pre class="context"> También es de notar que este es el primer algoritmo donde usamos llamadas recursivas, por su naturaleza de división y conquista.\\</pre>
<pre class="context"> </pre>
<pre class="context"> Aplicando el Teorema Maestro: $\mbox{T Mergesort(n)} = a * \mbox{T mergesort}(\frac{n}{b}) + f(n^c)$</pre>
<pre class="context"> </pre>
<pre class="delete">-La cantidad de llamadas recursivas (a) son dos. Cada llamada recursiva divide la entrada inicial a la mitad (b=2). Por último, el tiempo de las llamadas no recursivas es </pre>
<pre class="insert">+La cantidad de llamadas recursivas (a) son dos. Cada llamada recursiva divide la entrada inicial a la mitad (b=2). Por último, el tiempo de las llamadas no recursivas es</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mathcal O(2 + 2 + 1 + 1 + (n-1) 3 + 1 + 1) = \mathcal O(3n + 5)) \in \mathcal O(n)$\\</pre>
<pre class="insert">+$\bigO(2 + 4 + 1 + 2 + (n-1) * 3 + 1 + 1 + 1) = \bigO(3n + 9)) \in \bigO(n)$\\</pre>
<pre class="context"> </pre>
<pre class="context"> Asumiendo un n lo suficientemente grande como para que se requieran intercalar aproximadamente n elementos la mayoría de las veces, por lo que c=1. Se tiene entonces:</pre>
<pre class="context"> </pre>
<pre class="context"> $\mbox{T Mergesort(n): } 2 * \mbox{T Mergesort} (\frac{n}{2}) + f(n)$</pre>
<pre class="context"> </pre>
<pre class="delete">-Como $(a = b^c)$, se tiene que: $\mbox{T Mergesort(n)} \in \mathcal O(n \log n)$\\</pre>
<pre class="insert">+Como $(a = b^c)$, se tiene que: $\mbox{T Mergesort(n)} \in \bigO(n \log n)$\\</pre>
<pre class="context"> </pre>
<pre class="delete">-Para el caso promedio, se puede considerar que no es lo más probable una distribución de los elementos en cada mitad de modo tal que las mismas pierdan elementos uniformemente (agregándose al sub arreglo ordenado), sino que es más probable que uno de los arreglos termine el ciclo con muchos más elementos que el otro (que termina sin ninguno). Podríamos decir que para las comparaciones, uno de los arreglos resulta con varios elementos mayores a la propia mayoría del otro, y por ende, este último terminará con una longitud considerable al terminar el ciclo, que en promedio se podría decir de n/2. El tiempo de las llamadas no recursivas es $\mathcal O(2 + 2 + 1 + 1 + (n-1) 3 + 1 + 1) = \mathcal O(3n + 5)) \in \mathcal O(n)$, nuevamente dejando: $\mbox{T Promedio Mergesort(n)} \in \mathcal O(n \log n)$ </pre>
<pre class="insert">+Para el caso promedio, se puede considerar que no es lo más probable una distribución de los elementos en cada mitad de modo tal que las mismas pierdan elementos uniformemente (agregándose al sub arreglo ordenado), sino que es más probable que uno de los arreglos termine el ciclo con muchos más elementos que el otro\footnote{Discutible. No disponemos de las herramientas para una justificación más solida.} (que termina sin ninguno). Podríamos decir que para las comparaciones, uno de los arreglos resulta con varios elementos mayores a la propia mayoría del otro, y por ende, este último terminará con una longitud considerable al terminar el ciclo, que en promedio se podría decir de $\frac{n}{2}$. El tiempo de las llamadas no recursivas es $\bigO(2 + 4 + 1 + 2 + \frac{n}{2}) * 3 + 1 + \frac{n}{2} + 1) = \bigO(2n + 11)) \in \bigO(n)$, nuevamente dejando: $\mbox{T Promedio Mergesort(n)} \in \bigO(n \log n)$</pre>
<pre class="context"> </pre>
<pre class="context"> \subsubsection{Quicksort}</pre>
<pre class="context"> </pre>
<pre class="delete">-Al igual que mergesort, quicksort utiliza la técnica de División y Conquista. Se elige un elemento del arreglo como pivote (en nuestra implementación se elige al primero) y a partir del pivote se arman tres arreglos: la de todos los elementos menores al pivote, la conformada solo por el pivote y los elementos iguales a este y la de todos los elementos mayores al pivote. Con esto se obtiene un orden relativo al pivote. El mecanismo antes descripto se repite recursivamente para cada parte. El arreglo final se obtiene concatenando lps subarreglos ordenados. Al igual que en Mergesort, siendo División y Conquista la técnica utlilizada, se usa el Teorema Maestro para calcular su complejidad.\\</pre>
<pre class="insert">+Al igual que mergesort, quicksort utiliza la técnica de División y Conquista. Se elige un elemento del arreglo como pivote (en nuestra implementación se elige al primero) y a partir del pivote se arman dos arreglos: la de todos los elementos menores al pivote y la de todos los elementos mayores o iguales al pivote. El pivote se toma como el elemento inicial del arreglo. Con esto se obtiene un orden relativo al pivote. El mecanismo antes descripto se repite recursivamente para cada parte. El arreglo final se obtiene concatenando lps subarreglos ordenados. Al igual que en Mergesort, siendo División y Conquista la técnica utlilizada, se usa el Teorema Maestro para calcular su complejidad.\\</pre>
<pre class="context"> </pre>
<pre class="context"> Considerando las complejidades analizadas hasta ahora (en código no hay nada nuevo) y aplicando el Teorema Maestro se tiene:</pre>
<pre class="context"> </pre>
<pre class="context"> $\mbox{T Quicksort(n)} = a * \mbox{T Quicksort}(\frac{n}{b}) + f(n^c)$</pre>
<pre class="context"> </pre>
<pre class="delete">-La cantidad de llamadas recursivas (a) son 2. El tiempo de las llamadas no recursivas es $\mathcal O(1 + 3 + 1 + n (1 + 2) + 1 + n) = \mathcal O(4n + 6) \in \mathcal O(n)$, por lo que c=1.\\</pre>
<pre class="insert">+La cantidad de llamadas recursivas (a) son 2. El tiempo de las llamadas no recursivas es $\bigO(1 + 3 + 1 + n (1 + 1) + 1 + n) = \bigO(4n + 5) \in \bigO(n)$, por lo que c=1.\\</pre>
<pre class="context"> </pre>
<pre class="delete">-En el caso promedio, b será igual a 2, ya que en un arreglo arbitrariamente grande, es mucho más probable tomar en cualquier posición a un elemento alejado de las cotas superiores e inferiores que muy próximo a ellas, por lo que la recursión dividirá el problema en “dos partes iguales” (probablemente nunca sean exactamente iguales, pero con un n arbitrariamente grande, las diferencias que puedan existir son despreciables en tanto el pivote elegido no esté lo suficientemente próximo a una cota superior o inferior). Para este caso, como $(a = b^c)$, se tiene que: $\mbox{T Promedio Quicksort(n)} \in \mathcal O(n \log n))$</pre>
<pre class="insert">+En el caso promedio, b será aproximadamente 2, ya que en un arreglo arbitrariamente grande, con una distribución aleatoria de elementos, es mucho más probable tomar en cualquier posición a un elemento más alejado de las cotas superiores que de la media, por lo que la recursión dividirá el problema en “dos partes iguales” (probablemente nunca sean exactamente iguales, pero con un n arbitrariamente grande, las diferencias que puedan existir son despreciables en tanto el pivote elegido no esté lo suficientemente próximo a una cota superior o inferior). Para este caso, como $(a = b^c)$, se tiene que: $\mbox{T Promedio Quicksort(n)} \in \bigO(n \log n))$</pre>
<pre class="context"> </pre>
<pre class="context"> \subsubsection{Heapsort}</pre>
<pre class="context"> </pre>
<pre class="info">@@ -143,14 +144,14 @@ En el heapsort se utiliza la estructura de cola de prioridad (heap). Se construy</pre>
<pre class="context"> Los tiempos del heap de mínimos implementado son:</pre>
<pre class="context"> </pre>
<pre class="context"> \begin{itemize}</pre>
<pre class="delete">-\item \texttt{Heapify}: $\mathcal O(n)$</pre>
<pre class="delete">-\item \texttt{Heappop}: $\mathcal O(\log n)$</pre>
<pre class="delete">-\item \texttt{Heapush}: $\mathcal O(\log n)$</pre>
<pre class="insert">+\item \texttt{Heapify}: $\bigO(n)$</pre>
<pre class="insert">+\item \texttt{Heappop}: $\bigO(\log n)$</pre>
<pre class="insert">+\item \texttt{Heapush}: $\bigO(\log n)$</pre>
<pre class="context"> \end{itemize}</pre>
<pre class="context"> </pre>
<pre class="delete">-Considerando todo esto queda: </pre>
<pre class="insert">+Considerando todo esto queda:</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Promedio Heapsort(n)} \in \mathcal O(n + 1 + n + 1 + 1 + n (1 + \log n)) = \mathcal O(3n + n \log n + 3) \in \mathcal O(n \log n)$ </pre>
<pre class="insert">+$\mbox{T Promedio Heapsort(n)} \in \bigO(n + 1 + n + 1 + 1 + n (1 + \log n)) = \bigO(3n + n \log n + 3) \in \bigO(n \log n)$</pre>
<pre class="context"> </pre>
<pre class="context"> \subsection{Peores tiempos}</pre>
<pre class="context"> </pre>
<pre class="info">@@ -158,74 +159,74 @@ $\mbox{T Promedio Heapsort(n)} \in \mathcal O(n + 1 + n + 1 + 1 + n (1 + \log n)</pre>
<pre class="context"> </pre>
<pre class="context"> Como se ve en el análisis, el comportamiento de este algoritmo no depende de las características del arreglo. En términos más específicos, el algoritmo de selección no es un algoritmo “adaptativo”: su conducta no se ve afectada por ninguna característica del array, por lo cual realizará el mismo número de comparaciones e intercambios entre elementos tanto en el peor caso, en el caso promedio y en el mejor caso (considerando una longitud de arreglo arbitrariamente grande). Sin embargo, un arreglo considerado como el peor valor de entrada posible es un arreglo ordenado de forma descendente, debido a que nuestra implementación se busca el mínimo en cada iteración. Si bien asintóticamente no hay diferencia, diferirá en un valor constante el cual será mayor para un arreglo ordenado de esta forma.</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Peor Seleccción(n)} \in \mathcal O(n^2 + 6n + n) \in \mathcal O(n^2)$ </pre>
<pre class="insert">+$\mbox{T Peor Seleccción(n)} \in \bigO(n^2 + 6n + n) \in \bigO(n^2)$</pre>
<pre class="context"> </pre>
<pre class="context"> </pre>
<pre class="context"> \subsubsection{Inserción}</pre>
<pre class="context"> </pre>
<pre class="delete">-Este algoritmo sí presenta un peor caso: cuando el arreglo inicial se encuentra ordenado de forma descendente (y no al revés, según la implementación dada). El bucle interno del algoritmo deberá comparar cada elemento hasta llegar a la primera posición del conjunto, con lo cual realizará el máximo número de comparaciones posibles entre elementos y el ciclo se ejecutara sin cortes. Esto también está contemplado dentro de su comportamiento en promedio: se destaca el caso en que, si el arreglo estuviera ordenado al revés, el algoritmo terminaría en un orden de $\mathcal O(n)$ (siendo, para este caso trivial, mejor que cualquier ordenamiento).</pre>
<pre class="insert">+Este algoritmo sí presenta un peor caso: cuando el arreglo inicial se encuentra ordenado de forma descendente (y no al revés, según la implementación dada). El bucle interno del algoritmo deberá comparar cada elemento hasta llegar a la primera posición del conjunto, con lo cual realizará el máximo número de comparaciones posibles entre elementos y el ciclo se ejecutara sin cortes. Esto también está contemplado dentro de su comportamiento en promedio: se destaca el caso en que, si el arreglo estuviera ordenado al revés, el algoritmo terminaría en un orden de $\bigO(n)$ (siendo, para este caso trivial, mejor que cualquier ordenamiento).</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Peor Inserción(n)} \in \mathcal O(4n^2 + 8n + 3) \in \mathcal O(n^2)$</pre>
<pre class="insert">+$\mbox{T Peor Inserción(n)} \in \bigO(4n^2 + 8n + 3) \in \bigO(n^2)$</pre>
<pre class="context"> </pre>
<pre class="context"> \subsubsection{Mergesort}</pre>
<pre class="context"> </pre>
<pre class="delete">-Si bien tiene un promedio de tiempo logaritmico, tiene casos en los que realiza una mayor cantidad de comparaciones. El algoritmo se comporta de manera recursiva, dividiendo el arreglo en mitades cada vez mas pequeñas y realizando comparaciones entre ellas una vez alcanzado sub-arreglos de tamaño 1. Estas comparaciones serán, como máximo, de cantidad $n-1$ siendo $n$ la cantidad de elementos involucrados en cada comparación pues el ultimo elemento no hay que compararlo contra nada. De todas formas,  esto solo cambia la variable c del teorema del maestro, manteniendo la misma cota asintotica.</pre>
<pre class="insert">+Si bien tiene un promedio de tiempo linearítmico, tiene casos en los que realiza una mayor cantidad de comparaciones. El algoritmo se comporta de manera recursiva, dividiendo el arreglo en mitades cada vez mas pequeñas y realizando comparaciones entre ellas una vez alcanzado sub-arreglos de tamaño 1. Estas comparaciones serán, como máximo, de cantidad $n-1$ siendo $n$ la cantidad de elementos involucrados en cada comparación pues el ultimo elemento no hay que compararlo contra nada. De todas formas,  esto solo cambia la variable c del teorema del maestro, manteniendo la misma cota asintotica.</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Peor Mergesort(n)} \in \mathcal O(n \log n)$. </pre>
<pre class="insert">+$\mbox{T Peor Mergesort(n)} \in \bigO(n \log n)$.</pre>
<pre class="context"> </pre>
<pre class="context"> \subsubsection{Quicksort}</pre>
<pre class="context"> </pre>
<pre class="delete">-Quicksort presenta un caso en que su comportamiento resulta cuadrático, generando uno de las mayores discrepancias entre tiempo promedio y peor tiempo de los algoritmos analizados. Esto es cuando el pivote elegido es una cota menor o mayor elemento del arreglo, dividiendo el arreglo en dos partes de $1$ y $n-1$. En nuestra implementación, Quicksort elige siempre al primer elemento del arreglo como pivote, por lo tanto, usamos como peor caso un arreglo ordenado descendentemente y tomando de pivote el primer elemento del arreglo. Como en el caso promedio, para el peor caso se tiene que la primera iteración sin la llamada recursiva tiene un orden de $\mathcal O(4n + 6)$ (considerando como lineal lo que ocurre dentro del ciclo for, y sabiendo que al terminar la llamada recursiva se devolverá un nuevo arreglo de n elementos). </pre>
<pre class="insert">+Quicksort presenta un caso en que su comportamiento resulta cuadrático, generando uno de las mayores discrepancias entre tiempo promedio y peor tiempo de los algoritmos analizados. Esto es cuando el pivote elegido es una cota menor o mayor elemento del arreglo, dividiendo el arreglo en dos partes de $1$ y $n-1$. En nuestra implementación, Quicksort elige siempre al primer elemento del arreglo como pivote, por lo tanto, usamos como peor caso un arreglo ordenado descendentemente y tomando de pivote el primer elemento del arreglo. Como en el caso promedio, para el peor caso se tiene que la primera iteración sin la llamada recursiva tiene un orden de $\bigO(4n + 5)$ (considerando como lineal lo que ocurre dentro del ciclo for, y sabiendo que al terminar la llamada recursiva se devolverá un nuevo arreglo de n elementos).</pre>
<pre class="context"> </pre>
<pre class="delete">-Pero ahora, por ser el peor caso de quicksort, la llamada recursiva se hará con $n-1$ elementos (todos menos el pivote), y luego con $n-2$, y así sucesivamente hasta llegar al caso base cuyo orden complejidad es O(2). Pero al no haber División y Conquista propiamente dicho, no se puede aplicar el teorema del maestro. El analisis pasa a ser linea por linea:\\ </pre>
<pre class="insert">+Pero ahora, por ser el peor caso de quicksort, la llamada recursiva se hará con $n-1$ elementos (todos menos el pivote), y luego con $n-2$, y así sucesivamente hasta llegar al caso base cuyo orden complejidad es O(2). Pero al no haber División y Conquista propiamente dicho, no se puede aplicar el teorema del maestro. El analisis pasa a ser linea por linea:\\</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Peor Quicksort - Llamada sobre n:} = \mathcal O(4n) + \mathcal O(6) + O(2) + \mbox{Llamada sobre n-1}\\</pre>
<pre class="delete">-\mbox{Llamada sobre n-1} = \mathcal O(4n-1) + \mathcal O(6) + \mbox{Llamada sobre n-2} \\</pre>
<pre class="delete">-\mbox{Llamada sobre n-2} = \mathcal O(4n-2) + \mathcal O(6) + \mbox{Llamada sobre n-3}$ \\</pre>
<pre class="insert">+$\mbox{T Peor Quicksort - Llamada sobre n:} = \bigO(4n) + \bigO(5) + O(2) + \mbox{Llamada sobre n-1}\\</pre>
<pre class="insert">+\mbox{Llamada sobre n-1} = \bigO(4n-1) + \bigO(5) + \mbox{Llamada sobre n-2} \\</pre>
<pre class="insert">+\mbox{Llamada sobre n-2} = \bigO(4n-2) + \bigO(5) + \mbox{Llamada sobre n-3}$ \\</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Peor Quicksort:} \sum_{i=0}^{n-2} O(6)  +  \sum_{i=0}^{n-2} \mathcal O(4(n-i)) + \mathcal O(2) \\</pre>
<pre class="delete">-\mbox{T Peor Quicksort(n)} \in \mathcal O(6(n-1))  +  \mathcal O(4n(n-1)) - 4 * \sum_{i=0}^{n-2} \mathcal O(i) + \mathcal O(2) \\</pre>
<pre class="delete">-\mbox{T Peor Quicksort(n)} \in \mathcal O(6(n-1))  +  \mathcal O(4n(n-1)) - 4 * \mathcal O((n-1)*\frac n 2 + \mathcal O(2)$ \\</pre>
<pre class="insert">+$\mbox{T Peor Quicksort:} \sum_{i=0}^{n-2} O(5)  +  \sum_{i=0}^{n-2} \bigO(4(n-i)) + \bigO(2) \\</pre>
<pre class="insert">+\mbox{T Peor Quicksort(n)} \in \bigO(5(n-1))  +  \bigO(4n(n-1)) - 4 * \sum_{i=0}^{n-2} \bigO(i) + \bigO(2) \\</pre>
<pre class="insert">+\mbox{T Peor Quicksort(n)} \in \bigO(6(n-1))  +  \bigO(4n(n-1)) - 4 * \bigO((n-1)*\frac n 2 + \bigO(2)$ \\</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Peor Quicksort(n)} \in O(2 n ^2 + 4n - 4) \in \mathcal O(n^2)$</pre>
<pre class="insert">+$\mbox{T Peor Quicksort(n)} \in O(2 n ^2 + 3n - 4) \in \bigO(n^2)$</pre>
<pre class="context"> </pre>
<pre class="context"> \subsubsection{Heapsort}</pre>
<pre class="context"> </pre>
<pre class="context"> Para este algoritmo, el numero de comparaciones entre los elementos del arreglo puede variar en poca proporción dependiendo orden en que se presentan los mismos (según su ubicación en el heap).</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Peor Heapsort(n)} \in \mathcal O(3n + n \log n + 3) \in \mathcal O(n \log n)$</pre>
<pre class="insert">+$\mbox{T Peor Heapsort(n)} \in \bigO(3n + n \log n + 3) \in \bigO(n \log n)$</pre>
<pre class="context"> </pre>
<pre class="context"> \subsection{Comparación}</pre>
<pre class="context"> </pre>
<pre class="context"> \subsubsection{Tiempos promedio}</pre>
<pre class="context"> </pre>
<pre class="delete">-En orden ascendiente de eficiencia:\\</pre>
<pre class="insert">+En orden ascendente de eficiencia:\\</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Promedio Inserción(n)} \in \mathcal O(4n^2 + 8n + 3) \in \mathcal O(n^2)$</pre>
<pre class="insert">+$\mbox{T Promedio Inserción(n)} \in \bigO(4n^2 + 8n + 3) \in \bigO(n^2)$</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Promedio Seleccción(n)} \in \mathcal O(n^2 + 6n + n) \in \mathcal O(n^2)$</pre>
<pre class="insert">+$\mbox{T Promedio Seleccción(n)} \in \bigO(n^2 + 6n + n) \in \bigO(n^2)$</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Promedio Heapsort(n)} \in \mathcal O(3n + n \log n + 3) \in \mathcal O(n \log n)$ </pre>
<pre class="insert">+$\mbox{T Promedio Heapsort(n)} \in \bigO(3n + n \log n + 3) \in \bigO(n \log n)$</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Promedio Mergesort(n)} \in \mathcal O(n \log n)$ </pre>
<pre class="insert">+$\mbox{T Promedio Mergesort(n)} \in \bigO(n \log n)$</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Promedio Quicksort(n)} \in \mathcal O(n \log n)$\\</pre>
<pre class="insert">+$\mbox{T Promedio Quicksort(n)} \in \bigO(n \log n)$\\</pre>
<pre class="context"> </pre>
<pre class="delete">-Para poder terminar de ubicar en la escala a quicksort y mergesort, se pone el foco en la complejidad de su parte no recursiva: por parte de quicksort es $\mathcal O(4n + 6)$, y en el caso de mergesort es $\mathcal O(3n + 5)$. Es decir, la diferencia fundamental entre estos dos algoritmos es que en el peor caso quicksort será menos eficiente.</pre>
<pre class="insert">+Para poder terminar de ubicar en la escala a quicksort y mergesort, se pone el foco en la complejidad de su parte no recursiva: por parte de quicksort es $\bigO(4n + 5)$, y en el caso de mergesort es $\bigO(2n + 11)$. Es decir, la diferencia fundamental entre estos dos algoritmos es que en el peor caso quicksort será menos eficiente.</pre>
<pre class="context"> </pre>
<pre class="context"> \subsubsection{Peores tiempos}</pre>
<pre class="context"> </pre>
<pre class="delete">-En orden ascendiente de eficiencia:\\</pre>
<pre class="insert">+En orden ascendente de eficiencia:\\</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Peor Inserción(n)} \in \mathcal O(4n^2 + 8n + 3) \in \mathcal O(n^2)$</pre>
<pre class="insert">+$\mbox{T Peor Inserción(n)} \in \bigO(4n^2 + 8n + 3) \in \bigO(n^2)$</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Peor Seleccción(n)} \in \mathcal O(n^2 + 6n + n) \in \mathcal O(n^2)$ </pre>
<pre class="insert">+$\mbox{T Peor Quicksort(n)} \in O(2 n ^2 + 4n - 4) \in \bigO(n^2)$</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Peor Quicksort(n)} \in O(2 n ^2 + 4n - 4) \in \mathcal O(n^2)$</pre>
<pre class="insert">+$\mbox{T Peor Seleccción(n)} \in \bigO(n^2 + 6n + n) \in \bigO(n^2)$</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Peor Mergesort(n)} \in \mathcal O(n \log n) $</pre>
<pre class="insert">+$\mbox{T Peor Mergesort(n)} \in \bigO(n \log n) $</pre>
<pre class="context"> </pre>
<pre class="delete">-$\mbox{T Peor Heapsort(n)} \in \mathcal O(3n + n \log n + 3) \in \mathcal O(n \log n)$</pre>
<pre class="insert">+$\mbox{T Peor Heapsort(n)} \in \bigO(3n + n \log n + 3) \in \bigO(n \log n)$</pre>
<pre class="context"> </pre>
<pre class="context"> \subsection{Tiempos de ejecución}</pre>
<pre class="context"> </pre>
<pre class="info">@@ -239,7 +240,7 @@ Este es el peor caso analizado para los ordenamientos de inserción y de quickso</pre>
<pre class="context"> </pre>
<pre class="context"> \makebox[\textwidth][c]{\includegraphics[width=0.9\textwidth]{GraficoCasoAntiMergeSort}}\\ \\</pre>
<pre class="context"> </pre>
<pre class="delete">-Este es el peor caso analizado para mergesrot. El impacto práctico es virtualmente despreciable, mostrando que mergesort, incluso en su peor caso teórico, sigue siendo de los más eficientes. Esto se da porque este “peor caso” para mergesort, en realidad no está modificando su tiempo de ejecución a nivel asintótinco, por lo que en la práctica (ejecutado sobre el mismo ambiente) no se registran mayores diferencias. El resto de los algoritmos tienen un comportamiento similar al verificado con los sets aleatorios. </pre>
<pre class="insert">+Este es el peor caso analizado para mergesrot. El impacto práctico es virtualmente despreciable, mostrando que mergesort, incluso en su peor caso teórico, sigue siendo de los más eficientes. Esto se da porque este “peor caso” para mergesort, en realidad no está modificando su tiempo de ejecución a nivel asintótinco, por lo que en la práctica (ejecutado sobre el mismo ambiente) no se registran mayores diferencias. El resto de los algoritmos tienen un comportamiento similar al verificado con los sets aleatorios.</pre>
<pre class="context"> </pre>
<pre class="context"> \subsection{Comparación con valores teóricos}</pre>
<pre class="context"> </pre>
<pre class="info">@@ -253,11 +254,13 @@ Con respecto al caso promedio, los tiempos se cumplieron de forma exactamente co</pre>
<pre class="context"> </pre>
<pre class="context"> \subsubsection{Tiempo polinómico}</pre>
<pre class="context"> </pre>
<pre class="delete">-En el algoritmo implementado, primero se crea el archivo, con una complejidad $\mathcal O(E*J)$ (siendo J la cantidad de jugadores y E la cantidad de equipos), ya que por cada equipo se debe crear un archivo de longitud igual a la cantidad de jugadores, y lo análogo ocurre a la recíproca. La carga de archivos  naturalmente también es de orden $\mathcal O(J*E)$ ya que por cada jugador que se quiera crear, se debe recorrer un archivo cuya longitud es igual a la cantidad de equipos, y viceversa.</pre>
<pre class="insert">+En el algoritmo implementado, primero se crea el archivo, con una complejidad $\bigO(E*J)$ (siendo J la cantidad de jugadores y E la cantidad de equipos), ya que por cada equipo se debe crear un archivo de longitud igual a la cantidad de jugadores, y lo análogo ocurre a la recíproca. La carga de archivos  naturalmente también es de orden $\bigO(J*E)$ ya que por cada jugador que se quiera crear, se debe recorrer un archivo cuya longitud es igual a la cantidad de equipos, y viceversa.</pre>
<pre class="context"> </pre>
<pre class="delete">-Luego, en la asignación se genera el matching estable. La condición de corte es que no haya más vacantes en los equipos. En el algoritmo se itera por cada equipo y se verifica para cada uno si todos tiene vacantes, por lo que no agregan un orden diferente. Esto implica que cada equipo deberá completar todos sus lugares libres, y como hay igual cantidad de jugadores que de vacantes, el peor caso se considera cuando cada equipo debe preguntarle a todos los jugadores si desean ocupar una vacante: esto es $\mathcal O(J)$). Como hay E equipos, el orden de la asignación también es $\mathcal O(J*E)$.</pre>
<pre class="insert">+Luego, en la asignación se genera el matching estable. La condición de corte es que no haya más vacantes en los equipos. En el algoritmo se itera por cada equipo y se verifica para cada uno si todos tiene vacantes, por lo que no agregan un orden diferente. Esto implica que cada equipo deberá completar todos sus lugares libres, y como hay igual cantidad de jugadores que de vacantes, el peor caso se considera cuando cada equipo debe preguntarle a todos los jugadores si desean ocupar una vacante: esto es $\bigO(J)$). Como hay E equipos, el orden de la asignación también es $\bigO(J*E)$. Este orden está garantizado porque todas las operaciones dentro del ciclo son de orden constante.\footnote{Esto fue logrado en la re-entrega, al cambiar una \textbf{lista} de jugadores por un \textbf{diccionario} de jugadores, entre otros.}</pre>
<pre class="context"> </pre>
<pre class="delete">-Finalmente, se almacena en un archivo las asignaciones. Por cada equipo se guarda su número seguido de los sus jugadores, dejandolo en un orden lineal de $\mathcal O(J+E)$.</pre>
<pre class="insert">+</pre>
<pre class="insert">+</pre>
<pre class="insert">+Finalmente, se almacena en un archivo las asignaciones. Por cada equipo se guarda su número seguido de los sus jugadores, dejandolo en un orden lineal de $\bigO(J+E)$.</pre>
<pre class="context"> </pre>
<pre class="context"> El orden cuadrático polinomial del algoritmo es evidente, ya que es el peor caso de complejidad a lo largo de las funciones del algoritmo.</pre>
<pre class="context"> </pre>
<pre class="info">@@ -269,7 +272,7 @@ Como hay igual cantidad de jugadores que de vacantes totales, se ve que todos lo</pre>
<pre class="context"> </pre>
<pre class="context"> Para demostrar que una vez que cada equipo haya cubierto sus vacantes no habrá parejas conflictivas (inestabilidades). Suponiendo jugadores $j1$ y $j2$, y equipos $e1$, $e2$, asumimos un conflicto entre $(j1,e1)$ y $(j2,e2)$, con $j1$ queriendo estar en $e2$ y $j2$ queriendo estar en $e1$, $e1$ prefiriendo a $j2$ sobre $j1$ y $e2$ prefiriendo a $j1$ sobre $j2$.</pre>
<pre class="context"> </pre>
<pre class="delete">-Suponiendo que $e1$ es el primero en elegir, si $j1$ aceptó la vacante es porque estaba libre o porque prefería estar en $e1$ antes que en otro equipo $e3$ (donde no necesariamente $e3 = e2$).     </pre>
<pre class="insert">+Suponiendo que $e1$ es el primero en elegir, si $j1$ aceptó la vacante es porque estaba libre o porque prefería estar en $e1$ antes que en otro equipo $e3$ (donde no necesariamente $e3 = e2$).</pre>
<pre class="context"> </pre>
<pre class="context"> \begin{itemize}</pre>
<pre class="context"> \item{Si estaba solo: } Luego $e2$ prefiere más a $j2$ que a $j1$, porque le ofreció su vacante antes. Si esto no fuera así, $e2$ le hubiera ofrecido antes su vacante a $e1$, y el mismo se hubiera cambiado de equipo, pero esto no sucedió. En este caso se llega a un absurdo, porque por hipótesis $e2$ prefiere más a $j1$ (en otro caso la pareja no es conflictiva y no hay inestabilidad).</pre>
<pre class="info">@@ -286,7 +289,7 @@ Todas los caminos a los que conduce la hipótesis donde hay una inestabilidad en</pre>
<pre class="context"> </pre>
<pre class="context"> \section{Ejecución y compilación}</pre>
<pre class="context"> </pre>
<pre class="delete">-Todo el trabajo fue codificado en Python 3.6.1. </pre>
<pre class="insert">+Todo el trabajo fue codificado en Python 3.6.1.</pre>
<pre class="context"> </pre>
<pre class="context"> \subsection{Ordenamientos: Ejecución general}</pre>
<pre class="context"> </pre>
<pre class="info">@@ -398,7 +401,7 @@ heapSort        &amp; 0.09234720  &amp; 0.09180443  &amp; 0.09170632  &amp; 0.09235643  &amp; 0.0923</pre>
<pre class="context"> insertionSort   &amp; 4.72838785  &amp; 4.82092053  &amp; 4.71846541  &amp; 4.64045077  &amp; 4.54181549  &amp; 4.66178385  &amp; 4.71195490  &amp; 4.69176563  &amp; 4.71393896  &amp; 4.55890200  \\</pre>
<pre class="context"> mergeSort       &amp; 0.07408563  &amp; 0.07491511  &amp; 0.07442679  &amp; 0.07556444  &amp; 0.07424022  &amp; 0.07440036  &amp; 0.07488256  &amp; 0.07554801  &amp; 0.07454557  &amp; 0.07566138  \\</pre>
<pre class="context"> quickSort       &amp; 0.02859854  &amp; 0.02852403  &amp; 0.02988460  &amp; 0.02795936  &amp; 0.02736539  &amp; 0.03078863  &amp; 0.03012384  &amp; 0.03184481  &amp; 0.02881059  &amp; 0.03051086  \\</pre>
<pre class="delete">-selectionSort   &amp; 4.39602486  &amp; 4.53192356  &amp; 4.42551569  &amp; 4.38844704  &amp; 4.39688216  &amp; 4.38836099  &amp; 4.37352012  &amp; 4.36608303  &amp; 4.38014397  &amp; 4.41154632 </pre>
<pre class="insert">+selectionSort   &amp; 4.39602486  &amp; 4.53192356  &amp; 4.42551569  &amp; 4.38844704  &amp; 4.39688216  &amp; 4.38836099  &amp; 4.37352012  &amp; 4.36608303  &amp; 4.38014397  &amp; 4.41154632</pre>
<pre class="context"> \end{tabular}}</pre>
<pre class="context"> \end{table}</pre>
<pre class="context"> </pre>
<pre class="info">@@ -476,7 +479,7 @@ heapSort        &amp; 0.08850804            &amp; 0.09332258             &amp; 0.09097488</pre>
<pre class="context"> insertionSort   &amp; 0.93969506            &amp; 8.90286811             &amp; 4.92954869           \\</pre>
<pre class="context"> mergeSort       &amp; 0.05498279            &amp; 0.05593248             &amp; 0.07747910           \\</pre>
<pre class="context"> quickSort       &amp; 0.03932556            &amp; 5.78526304             &amp; 0.02463167           \\</pre>
<pre class="delete">-selectionSort   &amp; 4.08425468            &amp; 4.20178312             &amp; 4.48006365           </pre>
<pre class="insert">+selectionSort   &amp; 4.08425468            &amp; 4.20178312             &amp; 4.48006365</pre>
<pre class="context"> \end{tabular}</pre>
<pre class="context"> \end{adjustbox}</pre>
<pre class="context"> \end{table}</pre></div></div><h2>TP1/Ordenamientos/mergeSort.py</h2><div class="file-diff"><div><pre class="file">diff --git a/TP1/Ordenamientos/mergeSort.py b/TP1/Ordenamientos/mergeSort.py</pre>
<pre class="file">index e084456..668ed5b 100644</pre>
<pre class="delete">--- a/TP1/Ordenamientos/mergeSort.py</pre>
<pre class="insert">+++ b/TP1/Ordenamientos/mergeSort.py</pre>
<pre class="info">@@ -3,8 +3,13 @@ def mergeSort(array):</pre>
<pre class="context">         if l &lt; 2: return array</pre>
<pre class="context">         izq, der = mergeSort(array[:l//2]), mergeSort(array[l//2:])</pre>
<pre class="context">         resultado = []</pre>
<pre class="delete">-        while izq and der:</pre>
<pre class="delete">-                if izq[0] &lt; der[0]: resultado.append(izq.pop(0))</pre>
<pre class="delete">-                else: resultado.append(der.pop(0))</pre>
<pre class="delete">-        resultado.extend(izq) if izq else resultado.extend(der)</pre>
<pre class="insert">+        i, j = 0, 0</pre>
<pre class="insert">+        while i &lt; len(izq) and j &lt; len(der):</pre>
<pre class="insert">+                if izq[i] &lt; der[j]:</pre>
<pre class="insert">+                        resultado.append(izq[i])</pre>
<pre class="insert">+                        i+=1</pre>
<pre class="insert">+                else:</pre>
<pre class="insert">+                        resultado.append(der[j])</pre>
<pre class="insert">+                        j+=1</pre>
<pre class="insert">+        resultado.extend(izq[i:]) if j == len(der) else resultado.extend(der[j:])</pre>
<pre class="context">         return resultado</pre></div></div><h2>TP1/Ordenamientos/mergeTest.py</h2><div class="file-diff"><div><pre class="file">diff --git a/TP1/Ordenamientos/mergeTest.py b/TP1/Ordenamientos/mergeSortTest.py</pre>
<pre class="undefined">similarity index 70%</pre>
<pre class="undefined">rename from TP1/Ordenamientos/mergeTest.py</pre>
<pre class="undefined">rename to TP1/Ordenamientos/mergeSortTest.py</pre>
<pre class="file">index 1ec83a7..b32303c 100644</pre>
<pre class="delete">--- a/TP1/Ordenamientos/mergeTest.py</pre>
<pre class="insert">+++ b/TP1/Ordenamientos/mergeSortTest.py</pre>
<pre class="info">@@ -41,21 +41,21 @@ class TestListaDe500Elementos(unittest.TestCase):</pre>
<pre class="context">         self.assertEqual(result, arrayOrdenado)</pre>
<pre class="context"> </pre>
<pre class="context"> </pre>
<pre class="delete">-class TestListaDe1000Elementos(unittest.TestCase):</pre>
<pre class="delete">-</pre>
<pre class="delete">-    def test001OrdenarListaDe1000ElementosSort(self):</pre>
<pre class="delete">-        array = generarArrayRandom(1000, 0, 10000)</pre>
<pre class="delete">-        result = sorted(array)</pre>
<pre class="delete">-        arrayOrdenado = mergeSort(array)</pre>
<pre class="delete">-        self.assertEqual(result, arrayOrdenado)</pre>
<pre class="delete">-</pre>
<pre class="delete">-class TestListaDe10000Elementos(unittest.TestCase):</pre>
<pre class="delete">-</pre>
<pre class="delete">-    def test001OrdenarListaDe10000ElementosSort(self):</pre>
<pre class="delete">-        array = generarArrayRandom(10000, 0, 10000)</pre>
<pre class="delete">-        result = sorted(array)</pre>
<pre class="delete">-        arrayOrdenado = mergeSort(array)</pre>
<pre class="delete">-        self.assertEqual(result, arrayOrdenado)</pre>
<pre class="insert">+# class TestListaDe1000Elementos(unittest.TestCase):</pre>
<pre class="insert">+#</pre>
<pre class="insert">+#     def test001OrdenarListaDe1000ElementosSort(self):</pre>
<pre class="insert">+#         array = generarArrayRandom(1000, 0, 10000)</pre>
<pre class="insert">+#         result = sorted(array)</pre>
<pre class="insert">+#         arrayOrdenado = mergeSort(array)</pre>
<pre class="insert">+#         self.assertEqual(result, arrayOrdenado)</pre>
<pre class="insert">+</pre>
<pre class="insert">+# class TestListaDe10000Elementos(unittest.TestCase):</pre>
<pre class="insert">+#</pre>
<pre class="insert">+#     def test001OrdenarListaDe10000ElementosSort(self):</pre>
<pre class="insert">+#         array = generarArrayRandom(10000, 0, 10000)</pre>
<pre class="insert">+#         result = sorted(array)</pre>
<pre class="insert">+#         arrayOrdenado = mergeSort(array)</pre>
<pre class="insert">+#         self.assertEqual(result, arrayOrdenado)</pre>
<pre class="context"> </pre>
<pre class="context"> class TestListaOrdenada(unittest.TestCase):</pre>
<pre class="context"> </pre></div></div><h2>TP1/Ordenamientos/quickSort.py</h2><div class="file-diff"><div><pre class="file">diff --git a/TP1/Ordenamientos/quickSort.py b/TP1/Ordenamientos/quickSort.py</pre>
<pre class="file">index 5161814..ce568ca 100644</pre>
<pre class="delete">--- a/TP1/Ordenamientos/quickSort.py</pre>
<pre class="insert">+++ b/TP1/Ordenamientos/quickSort.py</pre>
<pre class="info">@@ -1,10 +1,10 @@</pre>
<pre class="context"> def quickSort(array):</pre>
<pre class="context">     if len(array) &lt; 2 : return array</pre>
<pre class="context">     pivote = array[0]</pre>
<pre class="delete">-    menores, pivotes, mayores = [], [], []</pre>
<pre class="delete">-    for elemento in array:</pre>
<pre class="delete">-        if elemento &lt; pivote:</pre>
<pre class="delete">-            menores.append(elemento)</pre>
<pre class="insert">+    menores, mayores = [], []</pre>
<pre class="insert">+    for x in range(1, len(array)):</pre>
<pre class="insert">+        if array[x] &lt; pivote:</pre>
<pre class="insert">+            menores.append(array[x])</pre>
<pre class="context">         else:</pre>
<pre class="delete">-            pivotes.append(elemento) if (elemento == pivote) else mayores.append(elemento)            </pre>
<pre class="delete">-    return quickSort(menores) + pivotes + quickSort(mayores)</pre>
<pre class="undefined">\ No newline at end of file</pre>
<pre class="insert">+            mayores.append(array[x])         </pre>
<pre class="insert">+    return quickSort(menores) + [pivote] + quickSort(mayores)</pre>
<pre class="undefined">\ No newline at end of file</pre></div></div><h2>TP1/Ordenamientos/quickTest.py</h2><div class="file-diff"><div><pre class="file">diff --git a/TP1/Ordenamientos/quickTest.py b/TP1/Ordenamientos/quickSortTest.py</pre>
<pre class="undefined">similarity index 100%</pre>
<pre class="undefined">rename from TP1/Ordenamientos/quickTest.py</pre>
<pre class="undefined">rename to TP1/Ordenamientos/quickSortTest.py</pre></div></div><h2>TP1/README.md</h2><div class="file-diff"><div><pre class="file">diff --git a/TP1/README.md b/TP1/README.md</pre>
<pre class="file">index fc84fe3..abbf32e 100644</pre>
<pre class="delete">--- a/TP1/README.md</pre>
<pre class="insert">+++ b/TP1/README.md</pre>
<pre class="info">@@ -2,3 +2,4 @@ Enunciado: https://algoritmos-rw.github.io/tda/2018-1c/tp1/</pre>
<pre class="context"> </pre>
<pre class="context"> Listado de tareas: https://docs.google.com/spreadsheets/d/1NN_zVbCaTUGX-g0UzVgLy0arU71vMqx0ZvKfCzNtTP4/edit#gid=0</pre>
<pre class="context"> </pre>
<pre class="insert">+Detalle de pendientes https://docs.google.com/document/d/1Ip9T-ibkdPxZMfpWz1O3jVRDxij5EWuycy-SyKH9TUg/edit</pre></div></div>
</div>


</body></html>